<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NiceWebP2P</title>
    <style id="style-connect-button">
        #webp2p-connect {
            position: absolute;
            display: block;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            font-family: sans-serif;
            padding: 0.7rem;
            border-radius: 1rem;
        }
    </style>
    <style id="style-message-app">
        body {
            background-color: lightgrey;
        }

        #message-app {
            position: absolute;
            display: flex;
            /* display: none; */
            flex-direction: column;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 90dvh;
            width: 50dvw;
            border: 5px solid black;
            border-radius: 2rem;
            background-color: #112;
            padding: 2rem;
            font-family: sans-serif;

            > :first-child {
                height: calc(100% - 2rem);
                margin-bottom: 1rem;
                overflow-y: auto;
                padding: 1rem;
                border-bottom: 2px solid #002;

                > p {
                    color: white;
                    position: relative;
                    font-size: 1.2rem;
                }

                p::after {
                    position: absolute;
                    top: 100%;
                    font-size: 0.7rem;
                    font-style: italic;
                }

                .self {
                    text-align: right;
                }

                .other {
                    text-align: left;
                }
                .self::after {
                    content: "[ Self ]";
                    right: 0;
                }

                .other::after {
                    content: "[ Other ]";
                    left: 0;
                }

                .failed {
                    color: red;
                }
            }

            > :last-child {
                width: 100%;
                display: flex;
                gap: 1rem;

                > *{
                    font-size: 1rem;
                    border-radius: 5px;
                }
                
                > input {
                    flex-grow: 1;
                }
            }
        }
    </style>
    <link rel="shortcut icon" href="data:" type="image/x-icon">
</head>
<body>
    <div id="message-app">
        <div></div>
        <div>
            <input type="text" onkeyup="if (event.key === 'Enter') {sendMessage(this.value); this.value = '';}">
            <button onclick="sendMessage(this.previousElementSibling.value); this.previousElementSibling.value = '';">Send</button>
        </div>
    </div>
    <button id="webp2p-connect" onclick="document.querySelector('custom-webp2p-dialogue').begin()">Connect</button>
    <custom-webp2p-dialogue onconnection="handleConnection(event)"></custom-webp2p-dialogue>
    <template id="template-webp2p-dialogue">
        <style>
            #webp2p-dialogue {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: #f7f7f7;
                border: 2px solid grey;
                border-radius: 2rem;
                width: 30dvw;
                text-align: center;
                font-family: sans-serif;
            }

            .stage {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                
                > * {
                    margin: 0;
                    width: 100%;
                    min-height: 2rem;
                    border-radius: 0.8rem;
                    margin-top: 0.5rem;
                    margin-bottom: 0.5rem;
                }

                > *:first-child {
                    margin-top: 0;
                }

                > *:last-child {
                    margin-bottom: 0;
                }
            }

            .info {
                height: 2rem;
                line-height: 2rem;
            }
            
            .copied {
                transition: all 400ms;
                overflow: hidden;
                min-height: 0;
                height: 2rem;
                font-weight: bold;
                margin-top: 0.2rem;
                margin-bottom: 0.2rem;
                opacity: 1;
            }
            
            .out-of-band {
                border: 1px solid grey;
                border-radius: 0.5rem;
                overflow-wrap: anywhere;
                padding: 0.5rem;
                background-color: white;
                cursor: pointer;
                resize: none;
            }
            
            .out-of-band:hover {
                background-color: #f0f0ff;
                box-shadow: inset 2px 2px darkgrey;
            }

            .hidden {
                height: 0;
                opacity: 0;
            }

            .pending {
                cursor: wait;
            }
        </style>
        <div id="webp2p-dialogue">
            <div id="begin" class="stage">
                <p class="info">Connect as</p>
                <button onclick="this.getRootNode().host.offer()">Host</button>
                <button onclick="this.getRootNode().host.offerToAnswer()">Player</button>
            </div>
            <div id="offer" class="stage">
                <p class="info">Send the following data to a player:</p>
                <p class="copied hidden">Copied!</p>
                <p class="out-of-band outbound" title="Click to Copy" onclick="this.getRootNode().host.outOfBandToClipboard(this.textContent)"></p>
                <p class="info">Enter data from the player:</p>
                <textarea class="out-of-band inbound" title="Paste Data Here" oninput="this.getRootNode().host.answerToComplete(this.value)"></textarea>
            </div>
            <div id="offer-to-answer" class="stage">
                <p class="info">Enter data from the host:</p>
                <textarea class="out-of-band inbound" title="Paste Data Here" oninput="this.getRootNode().host.answer(this.value)"></textarea>
            </div>
            <div id="answer" class="stage">
                <p class="info">Send the following data to the host:</p>
                <p class="copied hidden">Copied!</p>
                <p class="out-of-band outbound" title="Click to Copy" onclick="this.getRootNode().host.outOfBandToClipboard(this.textContent)"></p>
            </div>
            <div id="complete" class="stage">
                <p class="info">Setup Complete, Establishing</p>
            </div>
        </div>
    </template>
</body>
<script id="script-webp2p">
    "use strict";

    class WebP2PDialogue extends HTMLElement {
        static observedAttributes = ["onconnection"];
        static iceConfiguration = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun.l.google.com:5349" },
                { urls: "stun:stun1.l.google.com:3478" },
                { urls: "stun:stun1.l.google.com:5349" },
            ],
        };

        stages = {
            begin: null,
            offer: null,
            offerToAnswer: null,
            answer: null,
            complete: null,
        };
        connection = null;
        channel = null;
        acceptingManualIceCandidates = false;
        iceCandidateQueue = [];

        constructor() {
            super();

            this.attachShadow({mode: "open"});
            this.shadowRoot.appendChild(document.querySelector("#template-webp2p-dialogue").content.cloneNode(true));

            for (const stageName in this.stages) {
                this.stages[stageName] = this.shadowRoot.querySelector(`.stage#${stageName.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? "-" : "") + $.toLowerCase())}`);
                this.stages[stageName].defaultDisplay = this.stages[stageName].style.display;
            }

            this.shadowRoot.querySelectorAll("textarea").forEach(el => {
                el.autocomplete = "off";
                el.autocorrect = "off";
                el.autocapitalize = "off";
                el.spellcheck = "false";
                el.style.height = el.scrollHeight + "px";
                el.style.overflowY = "hidden";
                el.addEventListener("input", () => {
                    el.style.height = "auto";
                    el.style.height = el.scrollHeight + "px";
                });
            });
        }
        
        connectedCallback() {
            this.hide();
            this.addEventListener("connection", this.onconnection);
        }

        attributeChangedCallback(name, oldValue, newValue) {
            if (name !== "onconnection") return;
            this.removeEventListener("connection", this.onconnection);
            this.onconnection = Function(event, newValue);
            this.addEventListener("connection", this.onconnection);
        }

        onconnection(connection, channel) {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel === null) throw Error("channel was null");

            console.log("Set onconnection attribute to receive connection and channel");

            channel.close();
            connection.close();
        }

        show(stageName) {
            this.hide();
            this.style.display = "block";
            this.stages[stageName].style.display = this.stages[stageName].defaultDisplay;
        }
        hide() {
            this.style.display = "none";
            Object.values(this.stages).forEach(x => x.style.display = "none");
        }

        begin() {
            if (this.connection !== null) throw Error("connection was not null");
            if (this.channel !== null) throw Error("channel was not null");

            this.show("begin");
            
            this.connection = new RTCPeerConnection(this.iceConfiguration);
            this.connection.addEventListener("icecandidate", this.handleIceCandidate);
        }

        offer() {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel !== null) throw Error("channel was not null");

            this.show("offer");

            this.channel = this.connection.createDataChannel("channel");
            this.channel.addEventListener("open", this.success);

            const offer = this.connection
                .createOffer()
                .then((offer) => this.connection.setLocalDescription(offer))
                .then(() => {
                    const offerString = btoa(this.connection.localDescription.sdp);
                    this.stages.offer.querySelector(".out-of-band.outbound").textContent = offerString;
                    this.acceptManualIceCandidates();
                });
        }

        offerToAnswer() {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel !== null) throw Error("channel was not null");

            this.show("offerToAnswer");
        }

        answer(offerString) {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel !== null) throw Error("channel was not null");
            
            const offer = {type: "offer", sdp: atob(offerString.split(";")[0])};
            
            this.connection.addEventListener("datachannel", (event) => {
                this.channel = event.channel;
                this.channel.addEventListener("open", this.success);
                this.complete();
            });
            
            this.connection
                .setRemoteDescription(offer)
                .then(() => {
                    Promise
                        .all(offerString.split(";").slice(1).map(x => this.connection.addIceCandidate(JSON.parse(atob(x)))))        
                        .then(() => this.connection.createAnswer())
                        .then((answer) => this.connection.setLocalDescription(answer))
                        .then(() => {
                            const answerString = btoa(this.connection.localDescription.sdp);
                            this.stages.answer.querySelector(".out-of-band.outbound").textContent = answerString;
                            this.acceptManualIceCandidates();
                            this.show("answer");
                        });
                });
        }

        answerToComplete(answerString) {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel === null) throw Error("channel was null");

            const answer = {type: "answer", sdp: atob(answerString.split(";")[0])};
            
            this.connection
                .setRemoteDescription(answer)
                .then(() => {
                    Promise
                        .all(answerString.split(";").slice(1).map(x => this.connection.addIceCandidate(JSON.parse(atob(x)))))
                        .then(() => this.complete());
                });
        }

        complete() {
            if (this.connection === null) throw Error("connection was null");
            if (this.channel === null) throw Error("channel was null");

            this.show("complete");
        }
        
        success = (event) => {
            this.hide();
            [...this.shadowRoot.querySelectorAll(".out-of-band.outbound")].forEach(el => el.textContent = "");
            [...this.shadowRoot.querySelectorAll(".out-of-band.inbound")].forEach(el => {
                el.value = ""
                el.style.height = "auto";
                el.style.height = el.scrollHeight + "px";
            });

            const connectionEvent = new CustomEvent("connection", {detail: {
                connection: this.connection,
                channel: this.channel,
            }})
            this.dispatchEvent(connectionEvent);
            this.channel = null;
            this.connection = null;
        }

        outOfBandToClipboard(text) {
            if (this.acceptingManualIceCandidates) return;
            navigator.clipboard.writeText(text);
            this.shadowRoot.querySelectorAll(".copied").forEach(el => el.classList.remove("hidden"));
            setTimeout(() => {this.querySelectorAll(".copied").forEach(el => el.classList.add("hidden"))}, 3000);
        }

        acceptManualIceCandidates(duration=100) {
            this.acceptingManualIceCandidates = true;
            this.shadowRoot.querySelectorAll(".out-of-band.outbound").forEach(el => el.classList.add("pending"));
            
            setTimeout(() => {
                this.acceptingManualIceCandidates = false;
                this.shadowRoot.querySelectorAll(".out-of-band.outbound").forEach(el => el.classList.remove("pending"));
            }, duration);
        }

        handleIceCandidate = (event) => {
            this.iceCandidateQueue.push(event.candidate);
            if (!this.acceptingManualIceCandidates) return;
            while (this.iceCandidateQueue.length > 0) {
                const iceCandidateString = btoa(JSON.stringify(this.iceCandidateQueue.pop()));
                this.shadowRoot.querySelectorAll(".out-of-band.outbound").forEach(el => el.textContent += ";" + iceCandidateString);
            }
        }
    }
    customElements.define("custom-webp2p-dialogue", WebP2PDialogue);
</script>
<script>
    let connection = null;
    let channel = null;

    function handleConnection(event) {
        console.log("Received a connection and channel!");

        document.querySelector("#webp2p-connect").style.display = "none";

        connection = event.detail.connection;
        channel = event.detail.channel;

        // Allow time for other end to set event listeners
        channel.addEventListener("message", event => handleMessage(event.data));
        channel.addEventListener("close", handleClose);

        setTimeout(() => {
            begin();
        }, 1000);
    }

    function handleMessage(message) {
        console.log("In <- ", message);

        const selfMessage = document.createElement("p");
        selfMessage.classList.add("other");
        selfMessage.textContent = message;

        const messageDiv = document.querySelector("#message-app>:first-child");
        messageDiv.append(selfMessage);
        messageDiv.scrollTop = messageDiv.scrollHeight;
    }

    function handleClose(event) {
        console.log("Channel was closed.");
        console.log(event);

        document.querySelector("#webp2p-connect").style.display = "block";
        handleMessage("~Disconnected~");

        connection.close();
        channel.close();        
        connection = null;
        channel = null;
    }

    function begin() {
        console.log("Begun!");
        channel.send("~Connected~");
    }

    function sendMessage(message) {
        if (message.length === 0) return;
        console.log("Out ->", message);

        const selfMessage = document.createElement("p");
        selfMessage.classList.add("self");
        selfMessage.textContent = message;

        const messageDiv = document.querySelector("#message-app>:first-child");
        messageDiv.append(selfMessage);
        messageDiv.scrollTop = messageDiv.scrollHeight;

        if (connection === null || channel === null) {
            selfMessage.classList.add("failed");
        } else {
            channel.send(message);
        }
    }
</script>
</html>